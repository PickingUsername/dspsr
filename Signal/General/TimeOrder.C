#include "dsp/Transformation.h"
#include "dsp/TimeSeries.h"
#include "dsp/BitSeries.h"

#include "dsp/TimeOrder.h"

dsp::TimeOrder::TimeOrder() : Transformation<TimeSeries,BitSeries>("TimeOrder",outofplace){ }

dsp::TimeOrder::~TimeOrder(){ }

void dsp::TimeOrder::transformation(){
  if(input->get_nbit()!=32)
    throw Error(InvalidState,"dsp::ChannelOrder::transformation()",
		"nbit!=32- this routine is only set up for floats generated by dsp::TimeOrder\n");

  output->Observation::operator=( *input );
  output->resize( input->get_ndat() );

  // number of floats between (t0,f0) and (t1,f0) of a BitSeries
  register const unsigned output_stride = output->get_nchan()*output->get_npol()*output->get_ndim();

  register const unsigned input_stride = input->get_ndim();

  if( verbose )
    fprintf(stderr,"dsp::TimeOrder::transformation() got output_stride=%d input_stride=%d swap=%s\n",
	    output_stride, input_stride, input->get_swap()?"true":"false");

  if( !input->get_swap() ){

    for( unsigned idim=0; idim<input->get_ndim(); idim++){
      for( unsigned ichan=0; ichan<input->get_nchan(); ichan++){
	for( unsigned ipol=0; ipol<input->get_npol(); ipol++){
	  float* in = ((float*)input->get_datptr(ichan,ipol))+idim;
	  float* out = (float*)output->get_offset_ptr(ichan,ipol,idim);
	  
	  register const unsigned isamp_end = input->get_ndat()*input->get_ndim(); 
	  register unsigned output_samp=0;
	  
	  //if( verbose )
	  //fprintf(stderr,"dsp::TimeOrder::transformation() got idim=%d ichan=%d ipol=%d input->data=%p in=%p diff=%d output->data=%p out=%p diff=%d\n",
	  //    idim, ichan, ipol,
	  //    input->get_datptr(0,0), in, in-input->get_datptr(0,0),
	  //    output->get_rawptr(), out, out-(float*)output->get_rawptr()); 

	  for( unsigned isamp=0; isamp<isamp_end;
	       isamp+=input_stride, output_samp+=output_stride)
	    out[output_samp] = in[isamp];
	  
	}
      }
    }     
    
    
  }
  
  else {
 
    unsigned idim;

    for( idim=0; idim<input->get_ndim(); idim++){
      for( unsigned ichan=0; ichan<input->get_nchan()/2; ichan++){
	for( unsigned ipol=0; ipol<input->get_npol(); ipol++){
	  float* in = ((float*)input->get_datptr(ichan,ipol))+idim;
	  float* out = (float*)output->get_offset_ptr(ichan+input->get_nchan()/2,ipol,idim);
	  
	  register const unsigned isamp_end = input->get_ndat()*input->get_ndim(); 
	  register unsigned output_samp=0;
	  
	  for( unsigned isamp=0; isamp<isamp_end;
	       isamp+=input_stride, output_samp+=output_stride)
	    out[output_samp] = in[isamp];
	}
      }
    }

    for( idim=0; idim<input->get_ndim(); idim++){
      for( unsigned ichan=input->get_nchan()/2; ichan<input->get_nchan(); ichan++){
	for( unsigned ipol=0; ipol<input->get_npol(); ipol++){
	  float* in = ((float*)input->get_datptr(ichan,ipol))+idim;
	  float* out = (float*)output->get_offset_ptr(ichan-input->get_nchan()/2,ipol,idim);
	  
	  register const unsigned isamp_end = input->get_ndat()*input->get_ndim(); 
	  register unsigned output_samp=0;
	  
	  for( unsigned isamp=0; isamp<isamp_end;
	       isamp+=input_stride, output_samp+=output_stride)
	    out[output_samp] = in[isamp];
	}
      }
    }
    
    output->set_swap( false );
  }

}
